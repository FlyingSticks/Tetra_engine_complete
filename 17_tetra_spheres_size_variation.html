<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetrahedral Proof: Size Independence</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #050505; color: #fff; font-family: monospace; overflow: hidden; }
        #visualization { width: 100vw; height: 100vh; }
        
        .hud { 
            position: absolute; top: 10px; left: 10px; z-index: 100; 
            background: rgba(10, 10, 15, 0.95); 
            padding: 15px; width: 380px;
            border: 1px solid #333; border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.8);
            display: flex; flex-direction: column;
            max-height: 95vh;
        }
        
        #data-panel { flex-grow: 1; overflow-y: auto; padding-right: 5px; margin-bottom: 10px; }
        
        /* Table Styling */
        .row { display: grid; grid-template-columns: 1.5fr 1fr 1fr 1fr; gap: 4px; font-size: 11px; margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; align-items: center;}
        .header { font-weight: bold; color: #666; border-bottom: 1px solid #555; margin-bottom: 8px; }
        .group-header { grid-column: 1 / -1; font-size: 10px; color: #ffaa00; text-transform: uppercase; margin-top: 8px; margin-bottom: 2px; border-bottom: 1px dashed #333; }
        
        .val { text-align: right; font-family: 'Courier New', monospace; }
        .match { color: #00ff00; }
        .mismatch { color: #ff4444; }
        
        .controls { border-top: 1px solid #333; padding-top: 10px; }
        .slider-row { margin-bottom: 8px; }
        .slider-row label { display: block; font-size: 11px; color: #888; margin-bottom: 2px; }
        .slider-row input { width: 100%; accent-color: #00e5ff; }
        
        .legend { font-size: 10px; color: #666; margin-top: 5px; line-height: 1.3; }
    </style>
</head>
<body>

<div class="hud">
    <h3 style="margin:0 0 10px 0; color:#00e5ff; font-size:14px; text-transform:uppercase;">Calibration Proof</h3>
    
    <div class="row header">
        <span>Target</span>
        <span style="text-align:right">Blob Size</span>
        <span style="text-align:right">Aspect</span>
        <span style="text-align:right">Calc Z</span>
    </div>
    
    <div id="data-panel"></div>

    <div class="controls">
        <div class="slider-row">
            <label>Vertical Slit (Blue) Z: <span id="v-val">150</span></label>
            <input type="range" id="sl-v" min="50" max="300" value="150" step="1">
        </div>
        <div class="slider-row">
            <label>Horizontal Slit (Green) Z: <span id="h-val">250</span></label>
            <input type="range" id="sl-h" min="50" max="300" value="250" step="1">
        </div>
        <div class="legend">
            PROOF: Group 1 (Red) has a huge size difference, yet the Aspect Ratio is identical (1.80), yielding the correct Z=0 for both.
        </div>
    </div>
</div>

<div id="visualization"></div>

<script>
    // --- Config ---
    const SCREEN_Z = 500;
    
    const TARGETS = [
        // GROUP 1: Size Independence (Red)
        { id: "Tiny (Z=0)",   r: 6,   x: -50, y: 50, z: 0,   color: '#ff4444', grp: 'Group 1: Size Diff' },
        { id: "Huge (Z=0)",   r: 35,  x: 50,  y: 50, z: 0,   color: '#ff4444', grp: 'Group 1: Size Diff' },

        // GROUP 2: Depth Sensitivity (Green)
        { id: "Near (-50)",   r: 15,  x: -50, y: -50, z: -50, color: '#44ff44', grp: 'Group 2: Depth Diff' },
        { id: "Deep (80)",    r: 15,  x: 50,  y: -50, z: 80,  color: '#44ff44', grp: 'Group 2: Depth Diff' },

        // GROUP 3: The Ambiguity Trick (Blue/Yellow)
        { id: "Sm/Close",     r: 10,  x: -20, y: 0,   z: -80, color: '#4444ff', grp: 'Group 3: The "Trick"' },
        { id: "Lg/Far",       r: 30,  x: 20,  y: 0,   z: 100, color: '#ffff44', grp: 'Group 3: The "Trick"' }
    ];

    // --- Helpers ---
    // Pre-calculate Unit Sphere Points
    const UNIT_SPHERE = (function(){
        let x=[], y=[], z=[];
        let steps=12; 
        for(let i=0; i<=steps; i++){
            let lat = (i/steps)*Math.PI;
            for(let j=0; j<=steps*2; j++){
                let lon = (j/(steps*2))*2*Math.PI;
                x.push(Math.sin(lat) * Math.cos(lon));
                y.push(Math.sin(lat) * Math.sin(lon));
                z.push(Math.cos(lat));
            }
            x.push(null); y.push(null); z.push(null);
        }
        return {x,y,z};
    })();

    function getTransformedSphere(cx, cy, cz, r) {
        let x = UNIT_SPHERE.x.map(v => v===null ? null : cx + v*r);
        let y = UNIT_SPHERE.y.map(v => v===null ? null : cy + v*r);
        let z = UNIT_SPHERE.z.map(v => v===null ? null : cz + v*r);
        return {x,y,z};
    }

    function projectPoint(x, y, z, zv, zh) {
        let dv = zv - z; if(Math.abs(dv) < 0.1) dv = 0.1;
        let dh = zh - z; if(Math.abs(dh) < 0.1) dh = 0.1;
        let mx = -x / dv;
        let my = -y / dh;
        return {
            x: x + mx * (SCREEN_Z - z),
            y: y + my * (SCREEN_Z - z),
            z: SCREEN_Z
        };
    }

    function solveDepth(w, h, zv, zh) {
        if(h < 0.001) return null;
        let ar = w/h;
        let tv = SCREEN_Z - zv;
        let th = SCREEN_Z - zh;
        let num = (ar * zv * th) - (zh * tv);
        let den = (ar * th) - tv;
        if(Math.abs(den) < 0.001) return null;
        return num / den;
    }

    // --- Render Loop ---
    const slV = document.getElementById('sl-v');
    const slH = document.getElementById('sl-h');
    const dispV = document.getElementById('v-val');
    const dispH = document.getElementById('h-val');
    const dataPanel = document.getElementById('data-panel');

    function update() {
        const zv = parseFloat(slV.value);
        const zh = parseFloat(slH.value);
        dispV.innerText = zv; dispH.innerText = zh;

        // BATCHING: We separate by COLOR to keep Plotly happy but fast.
        // We will have 4 main batches: Red, Green, Blue, Yellow
        const BATCHES = {};
        
        let html = "";
        let curGrp = "";

        TARGETS.forEach(t => {
            // HUD HTML
            if(t.grp !== curGrp) {
                html += `<div class="group-header">${t.grp}</div>`;
                curGrp = t.grp;
            }

            // Init batch if new color
            if(!BATCHES[t.color]) BATCHES[t.color] = { srcX:[], srcY:[], srcZ:[], projX:[], projY:[], projZ:[], boxX:[], boxY:[], boxZ:[] };
            let B = BATCHES[t.color];

            // 1. Source Geometry
            let geo = getTransformedSphere(t.x, t.y, t.z, t.r);
            B.srcX.push(...geo.x, null);
            B.srcY.push(...geo.y, null);
            B.srcZ.push(...geo.z, null);

            // 2. Projection Calc
            let p_left = projectPoint(t.x - t.r, t.y, t.z, zv, zh).x;
            let p_right = projectPoint(t.x + t.r, t.y, t.z, zv, zh).x;
            let w_proj = Math.abs(p_right - p_left);

            let p_top = projectPoint(t.x, t.y + t.r, t.z, zv, zh).y;
            let p_bot = projectPoint(t.x, t.y - t.r, t.z, zv, zh).y;
            let h_proj = Math.abs(p_top - p_bot);

            let area = Math.round(w_proj * h_proj);
            let ar = w_proj / h_proj;
            let z_calc = solveDepth(w_proj, h_proj, zv, zh);

            // 3. HUD Row
            let z_disp = z_calc !== null ? z_calc.toFixed(1) : "ERR";
            let err = z_calc !== null ? Math.abs(z_calc - t.z) : 999;
            let css = err < 1.0 ? "match" : "mismatch";
            
            html += `
                <div class="row" style="color:${t.color}">
                    <span>${t.id}</span>
                    <span class="val">${area}</span>
                    <span class="val" style="color:#00e5ff">${ar.toFixed(2)}</span>
                    <span class="val ${css}">${z_disp}</span>
                </div>`;

            // 4. Projection Geometry
            let px=[], py=[], pz=[];
            for(let i=0; i<geo.x.length; i++){
                if(geo.x[i]===null) { px.push(null); py.push(null); pz.push(null); }
                else {
                    let p = projectPoint(geo.x[i], geo.y[i], geo.z[i], zv, zh);
                    px.push(p.x); py.push(p.y); pz.push(p.z);
                }
            }
            B.projX.push(...px, null);
            B.projY.push(...py, null);
            B.projZ.push(...pz, null);

            // 5. Box Geometry
            let bx = [p_left, p_right, p_right, p_left, p_left, null];
            let by = [p_top, p_top, p_bot, p_bot, p_top, null];
            let bz = [SCREEN_Z, SCREEN_Z, SCREEN_Z, SCREEN_Z, SCREEN_Z, null];
            B.boxX.push(...bx);
            B.boxY.push(...by);
            B.boxZ.push(...bz);
        });

        dataPanel.innerHTML = html;

        // --- BUILD PLOTLY DATA ---
        let data = [];
        
        // Add batches
        for(let color in BATCHES) {
            let B = BATCHES[color];
            // Source Trace
            data.push({
                type: 'scatter3d', mode: 'lines',
                x: B.srcX, y: B.srcY, z: B.srcZ,
                line: {color: color, width: 2}, opacity: 0.3, hoverinfo: 'none'
            });
            // Projection Trace
            data.push({
                type: 'scatter3d', mode: 'lines',
                x: B.projX, y: B.projY, z: B.projZ,
                line: {color: color, width: 5}, hoverinfo: 'none'
            });
            // Box Trace
            data.push({
                type: 'scatter3d', mode: 'lines',
                x: B.boxX, y: B.boxY, z: B.boxZ,
                line: {color: 'white', width: 1, dash: 'dot'}, opacity: 0.5, hoverinfo: 'none'
            });
        }

        // Slits
        data.push({x:[0,0], y:[-300,300], z:[zv,zv], mode:'lines', line:{color:'cyan', width:4}, type:'scatter3d', hoverinfo:'none'});
        data.push({x:[-300,300], y:[0,0], z:[zh,zh], mode:'lines', line:{color:'lime', width:4}, type:'scatter3d', hoverinfo:'none'});
        
        // Screen
        let s = 400;
        data.push({
            x:[-s,s,s,-s,-s], y:[s,s,-s,-s,s], z:[SCREEN_Z,SCREEN_Z,SCREEN_Z,SCREEN_Z,SCREEN_Z],
            mode:'lines', line:{color:'#333', width:2}, type:'scatter3d', hoverinfo:'none'
        });

        let layout = {
            paper_bgcolor: '#050505', plot_bgcolor: '#050505',
            margin: {l:0, r:0, b:0, t:0}, showlegend: false,
            scene: {
                xaxis: {visible:false}, yaxis: {visible:false},
                zaxis: {title: 'Depth', range: [-150, 600], gridcolor: '#222'},
                camera: {eye: {x:1.5, y:0.8, z:0.5}},
                dragmode: 'orbit'
            }
        };

        Plotly.react('visualization', data, layout);
    }

    slV.addEventListener('input', update);
    slH.addEventListener('input', update);
    
    // Init
    update();

</script>
</body>
</html>