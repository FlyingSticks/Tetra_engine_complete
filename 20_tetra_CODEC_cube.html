<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetra Codec: Metric Cube (Point Cloud)</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #050505; color: #fff; font-family: 'Segoe UI', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        
        header { 
            height: 40px; background: #111; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
        }
        h1 { font-size: 14px; margin: 0; color: #00ffaa; letter-spacing: 1px; text-transform: uppercase; }
        .tag { background: #222; padding: 2px 6px; border-radius: 4px; font-size: 10px; color: #aaa; border: 1px solid #444; }

        #container { flex: 1; display: flex; position: relative; }
        .panel { flex: 1; position: relative; border-right: 1px solid #222; display: flex; flex-direction: column; }
        
        .overlay-info { 
            position: absolute; top: 10px; left: 10px; z-index: 10; 
            background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 4px; border: 1px solid #444; pointer-events: none;
        }
        .info-title { font-size: 12px; font-weight: bold; color: #eee; }
        .info-detail { font-size: 10px; color: #aaa; margin-top: 2px; }
        
        .plot-div { flex: 1; width: 100%; height: 100%; }

        #connection {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 20;
            background: #000; border: 1px solid #333; padding: 5px 15px; border-radius: 15px;
            font-size: 11px; color: #00ffaa; font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.2);
        }
    </style>
</head>
<body>

<header>
    <h1>Tetra Codec <span style="color:#666">//</span> LINEARITY PROOF</h1>
    <div class="tag">OBJ: WIREFRAME_CUBE</div>
</header>

<div id="container">
    <div class="panel">
        <div class="overlay-info">
            <div class="info-title">SERVER FEED (2D)</div>
            <div class="info-detail">Observation: Straight edges appear CURVED</div>
            <div class="info-detail">Stream: High-Density Point Cloud</div>
        </div>
        <div id="plot-server" class="plot-div"></div>
    </div>

    <div id="connection">STREAMING</div>

    <div class="panel" style="border-right: none;">
        <div class="overlay-info">
            <div class="info-title">CLIENT VIEW (3D)</div>
            <div class="info-detail">Observation: Edges are perfectly STRAIGHT</div>
            <div class="info-detail">Action: Drag to Rotate</div>
        </div>
        <div id="plot-client" class="plot-div"></div>
    </div>
</div>

<script>
    // --- 1. SETTINGS (Sensor-Centric V2) ---
    const RENDER_SETTINGS = {
        zv: 150,    
        zh: 250,    
        zs: 0      
    };
    
    // --- 2. GENERATE CUBE (Point Cloud) ---
    const VERTICES = [];
    const CUBE_SIZE = 40; 
    const DENSITY = 40; // Points per edge
    
    function addEdge(p1, p2, color) {
        for(let i=0; i<=DENSITY; i++) {
            let t = i/DENSITY;
            VERTICES.push({
                x: p1.x + (p2.x - p1.x)*t,
                y: p1.y + (p2.y - p1.y)*t,
                z: p1.z + (p2.z - p1.z)*t,
                col: color
            });
        }
    }

    // Define 8 Corners
    const s = CUBE_SIZE/2;
    const c = [
        {x:-s, y:s, z:-s}, {x:s, y:s, z:-s}, {x:s, y:-s, z:-s}, {x:-s, y:-s, z:-s}, // Front
        {x:-s, y:s, z:s},  {x:s, y:s, z:s},  {x:s, y:-s, z:s},  {x:-s, y:-s, z:s}   // Back
    ];
    
    // Build Edges
    // Front Face (Red)
    addEdge(c[0], c[1], '#ff4444'); addEdge(c[1], c[2], '#ff4444');
    addEdge(c[2], c[3], '#ff4444'); addEdge(c[3], c[0], '#ff4444');
    // Back Face (Blue)
    addEdge(c[4], c[5], '#4444ff'); addEdge(c[5], c[6], '#4444ff');
    addEdge(c[6], c[7], '#4444ff'); addEdge(c[7], c[4], '#4444ff');
    // Connectors (White)
    addEdge(c[0], c[4], '#ffffff'); addEdge(c[1], c[5], '#ffffff');
    addEdge(c[2], c[6], '#ffffff'); addEdge(c[3], c[7], '#ffffff');

    // --- 3. MATH ENGINE ---

    function encode(v, time) {
        // 1. World Transform (Spin Object)
        let ang = time * 0.01;
        
        // Rotate Y
        let rx = v.x * Math.cos(ang) - v.z * Math.sin(ang);
        let rz = v.x * Math.sin(ang) + v.z * Math.cos(ang);
        
        // Tumble X
        let tilt = 0.5;
        let ry = v.y * Math.cos(tilt) - rz * Math.sin(tilt);
        let rz_fin = v.y * Math.sin(tilt) + rz * Math.cos(tilt);
        
        // Place in Distal Zone (Z > 250)
        let z_world = 380 + rz_fin; 

        // 2. Project
        let den_v = z_world - RENDER_SETTINGS.zv;
        let den_h = z_world - RENDER_SETTINGS.zh;
        
        if(Math.abs(den_v)<1 || Math.abs(den_h)<1) return null;

        let u = rx * (-RENDER_SETTINGS.zv) / den_v;
        let v_coord = ry * (-RENDER_SETTINGS.zh) / den_h;

        // Blob Dimensions (Fixed radius projection for visibility)
        let r = 2; // Point radius
        let x_edge = (rx + r) * (-RENDER_SETTINGS.zv) / den_v;
        let w = Math.abs(x_edge - u) * 2;
        
        let y_edge = (ry + r) * (-RENDER_SETTINGS.zh) / den_h;
        let h = Math.abs(y_edge - v_coord) * 2;

        return { u, v: v_coord, w, h, col: v.col };
    }

    function decode(blob) {
        if(!blob || blob.h === 0) return null;
        
        let ar = blob.w / blob.h;
        let zv = RENDER_SETTINGS.zv;
        let zh = RENDER_SETTINGS.zh;
        
        // Solver V2.1
        let num = zv * zh * (ar - 1);
        let den = (ar * zh) - zv; 

        if(Math.abs(den) < 0.001) return null;
        let z_rec = num / den;

        let x_rec = blob.u * (z_rec - zv) / (-zv);
        let y_rec = blob.v * (z_rec - zh) / (-zh);
        
        return { x: x_rec, y: y_rec, z: z_rec, col: blob.col };
    }

    // --- 4. RENDER LOOP ---
    let time = 0;

    function update() {
        time++;
        
        let servX=[], servY=[], servC=[];
        let cliX=[], cliY=[], cliZ=[], cliC=[];

        VERTICES.forEach(v => {
            let blob = encode(v, time);
            if(blob) {
                // Server Data (2D Points)
                servX.push(blob.u);
                servY.push(blob.v);
                servC.push(blob.col);

                // Client Data (3D Points)
                let rec = decode(blob);
                if(rec) {
                    cliX.push(rec.x);
                    cliY.push(rec.y);
                    cliZ.push(rec.z);
                    cliC.push(rec.col);
                }
            }
        });

        // DRAW SERVER (2D Scatter)
        Plotly.react('plot-server', [{
            x: servX, y: servY, 
            mode: 'markers', 
            marker: { color: servC, size: 3 }, // Simple dots
            hoverinfo: 'none'
        }], {
            paper_bgcolor: '#000', plot_bgcolor: '#000',
            margin: {l:0,r:0,b:0,t:0},
            xaxis: {range: [-150, 150], visible:false},
            yaxis: {range: [-150, 150], visible:false},
            showlegend: false
        });

        // DRAW CLIENT (3D Scatter)
        Plotly.react('plot-client', [{
            type: 'scatter3d', mode: 'markers',
            x: cliX, y: cliY, z: cliZ,
            marker: { size: 2, color: cliC, opacity: 1 },
            hoverinfo: 'none'
        }], {
            paper_bgcolor: '#000', plot_bgcolor: '#000',
            margin: {l:0,r:0,b:0,t:0},
            showlegend: false,
            scene: {
                xaxis: {range: [-60,60], visible:false},
                yaxis: {range: [-60,60], visible:false},
                zaxis: {range: [320, 440], title: '', showgrid:false, zeroline:false, showticklabels:false},
                camera: { eye: {x: 1.4, y: 0.5, z: 0.5} }
            }
        });
        
        requestAnimationFrame(update);
    }

    update();

</script>
</body>
</html>