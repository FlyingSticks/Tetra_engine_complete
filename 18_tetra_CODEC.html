<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetra Codec: Fixed Prototype</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #050505; color: #fff; font-family: 'Segoe UI', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        
        header { 
            height: 40px; background: #111; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
        }
        h1 { font-size: 14px; margin: 0; color: #ff9900; letter-spacing: 1px; text-transform: uppercase; }
        .live-tag { color: #ff0000; font-weight: bold; font-size: 10px; animation: pulse 2s infinite; }
        @keyframes pulse { 0% {opacity: 1;} 50% {opacity: 0.5;} 100% {opacity: 1;} }

        #container { flex: 1; display: flex; position: relative; }
        
        .panel { flex: 1; position: relative; border-right: 1px solid #222; display: flex; flex-direction: column; }
        
        .overlay-info { 
            position: absolute; top: 10px; left: 10px; z-index: 10; 
            background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 4px; border: 1px solid #444; pointer-events: none;
        }
        .info-title { font-size: 12px; font-weight: bold; color: #eee; }
        .info-detail { font-size: 10px; color: #aaa; margin-top: 2px; }
        
        /* Debug Panel on Client Side */
        .debug-panel {
            position: absolute; bottom: 10px; left: 10px; z-index: 10;
            font-size: 10px; color: #00ff00; font-family: monospace;
            background: rgba(0,20,0,0.9); padding: 5px; border: 1px solid #004400;
            pointer-events: none;
        }

        .plot-div { flex: 1; width: 100%; height: 100%; }

        #connection {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 20;
            background: #000; border: 1px solid #333; padding: 5px 15px; border-radius: 15px;
            font-size: 11px; color: #00e5ff; font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.2);
        }
    </style>
</head>
<body>

<header>
    <h1>Tetra Codec <span style="color:#666">//</span> V2.1_FIXED</h1>
    <span class="live-tag">‚óè LIVE TRANSMISSION</span>
</header>

<div id="container">
    <div class="panel">
        <div class="overlay-info">
            <div class="info-title">SERVER FEED (ENCODED)</div>
            <div class="info-detail">Stream: 2D Video (MP4)</div>
            <div class="info-detail">Data: Shape = Depth</div>
        </div>
        <div id="plot-server" class="plot-div"></div>
    </div>

    <div id="connection">NETWORK</div>

    <div class="panel" style="border-right: none;">
        <div class="overlay-info">
            <div class="info-title">CLIENT VIEW (DECODED)</div>
            <div class="info-detail">Stream: Volumetric Point Cloud</div>
            <div class="info-detail">Action: Drag to Rotate</div>
        </div>
        
        <div class="debug-panel" id="debug-text">
            Waiting for stream...
        </div>
        
        <div id="plot-client" class="plot-div"></div>
    </div>
</div>

<script>
    // --- 1. CONFIGURATION (Sensor-Centric V2) ---
    const RENDER_SETTINGS = {
        zv: 150,    // Vertical Slit (X-Pinch)
        zh: 250,    // Horizontal Slit (Y-Pinch)
        zs: 0,      // Sensor is Origin (Z=0)
    };
    
    // GALAXY GEN
    const PARTICLE_COUNT = 150;
    const PARTICLES = [];
    for(let i=0; i<PARTICLE_COUNT; i++) {
        let angle = i * 0.15;
        let r = (i / PARTICLE_COUNT) * 60; 
        r += (Math.random()-0.5)*10;
        PARTICLES.push({
            id: i,
            x: r * Math.cos(angle),
            y: r * Math.sin(angle),
            z: (Math.random()-0.5)*40, // Thickness
            r: 3, 
            color: `hsl(${Math.floor(i/PARTICLE_COUNT*300)}, 80%, 60%)`
        });
    }

    // --- 2. MATH ENGINE ---

    // Encode: 3D -> 2D Screen Projection
    function encodeParticle(p, time) {
        // Physics Rotation
        let speed = 0.01;
        let rx = p.x * Math.cos(time*speed) - p.z * Math.sin(time*speed);
        let rz = p.x * Math.sin(time*speed) + p.z * Math.cos(time*speed);
        let ry = p.y; 

        // Place object in Distal Zone (Z > 250)
        let z_world = 350 + rz; 

        // Sensor-Centric Projection
        // x_screen = x_world * (-zv) / (z_world - zv)
        let den_v = z_world - RENDER_SETTINGS.zv;
        let den_h = z_world - RENDER_SETTINGS.zh;
        
        if(Math.abs(den_v)<1 || Math.abs(den_h)<1) return null;

        let x_s = rx * (-RENDER_SETTINGS.zv) / den_v;
        let y_s = ry * (-RENDER_SETTINGS.zh) / den_h;

        // Calc Width/Height (Projecting radius)
        let x_edge = (rx + p.r) * (-RENDER_SETTINGS.zv) / den_v;
        let w_proj = Math.abs(x_edge - x_s) * 2;
        
        let y_edge = (ry + p.r) * (-RENDER_SETTINGS.zh) / den_h;
        let h_proj = Math.abs(y_edge - y_s) * 2;

        return { u: x_s, v: y_s, w: w_proj, h: h_proj, col: p.color };
    }

    // Decode: 2D Blob -> 3D Point
    function decodeParticle(blob) {
        if(!blob || blob.h === 0) return null;
        
        let ar = blob.w / blob.h;
        let zv = RENDER_SETTINGS.zv;
        let zh = RENDER_SETTINGS.zh;
        
        // CORRECTED SOLVER V2.1
        // Z = ( Zv * Zh * (AR - 1) ) / ( AR * Zh - Zv )
        let num = zv * zh * (ar - 1);
        let den = (ar * zh) - zv; 

        if(Math.abs(den) < 0.001) return null;
        let z_rec = num / den;

        // Recover X/Y
        // x_rec = x_s * (z_rec - zv) / (-zv)
        let x_rec = blob.u * (z_rec - zv) / (-zv);
        let y_rec = blob.v * (z_rec - zh) / (-zh);
        
        return { x: x_rec, y: y_rec, z: z_rec, col: blob.col };
    }

    // --- 3. LOOP ---
    let time = 0;
    const debugText = document.getElementById('debug-text');

    // Unit circle for drawing blobs
    const CIRCLE = [];
    for(let i=0; i<=12; i++) {
        let t = (i/12)*Math.PI*2;
        CIRCLE.push([Math.cos(t), Math.sin(t)]);
    }

    function update() {
        time++;
        
        let serverShapes = []; // 2D Lines
        let clientX=[], clientY=[], clientZ=[], clientC=[];
        let debugZ = 0;

        PARTICLES.forEach(p => {
            let blob = encodeParticle(p, time);
            if(blob) {
                // Server Visuals (Blobs)
                // Draw manual ellipse
                let xPath=[], yPath=[];
                CIRCLE.forEach(pt => {
                    xPath.push(blob.u + pt[0]*(blob.w/2));
                    yPath.push(blob.v + pt[1]*(blob.h/2));
                });
                xPath.push(null); yPath.push(null); // Break line
                
                serverShapes.push({x: xPath, y: yPath, col: blob.col});

                // Client Decode
                let rec = decodeParticle(blob);
                if(rec) {
                    clientX.push(rec.x);
                    clientY.push(rec.y);
                    clientZ.push(rec.z);
                    clientC.push(rec.col);
                    debugZ = rec.z; // Capture last Z for debug
                }
            }
        });

        // --- UPDATE PLOTS ---
        
        // 1. Server Plot (2D) - Optimized with single trace per color logic is hard here, 
        // using single white trace for speed
        let flatX = [], flatY = [];
        serverShapes.forEach(s => { flatX.push(...s.x); flatY.push(...s.y); });
        
        Plotly.react('plot-server', [{
            x: flatX, y: flatY, mode: 'lines', 
            line: {color: 'white', width: 1}, hoverinfo:'none'
        }], {
            paper_bgcolor: '#000', plot_bgcolor: '#000',
            margin: {l:0,r:0,b:0,t:0},
            xaxis: {range: [-150, 150], visible:false},
            yaxis: {range: [-150, 150], visible:false},
            showlegend: false
        });

        // 2. Client Plot (3D)
        Plotly.react('plot-client', [{
            type: 'scatter3d', mode: 'markers',
            x: clientX, y: clientY, z: clientZ,
            marker: { size: 3, color: clientC, opacity: 0.8 },
            hoverinfo: 'none'
        }], {
            paper_bgcolor: '#000', plot_bgcolor: '#000',
            margin: {l:0,r:0,b:0,t:0},
            showlegend: false,
            scene: {
                // FIXED RANGE: Z is 250 to 450 (Distal Zone)
                xaxis: {range: [-100,100], visible:false},
                yaxis: {range: [-100,100], visible:false},
                zaxis: {range: [250, 450], title: 'Depth', gridcolor:'#333'},
                camera: { eye: {x: 1.5, y: 0.5, z: 0.5} }
            }
        });

        // Debug output
        debugText.innerText = `Points Decoded: ${clientX.length}\nSample Z: ${debugZ.toFixed(1)}\n(Should be ~350)`;
        
        requestAnimationFrame(update);
    }

    update();

</script>
</body>
</html>